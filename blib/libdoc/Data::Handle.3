.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.22)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Handle 3"
.TH Data::Handle 3 "2012-08-11" "perl v5.16.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Handle \- A Very simple interface to the _\|_DATA_\|_  file handle.
.SH "VERSION"
.IX Header "VERSION"
version 0.02001002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package Foo;
\&
\&    sub bar {
\&        my $handle = Data::Handle\->new( _\|_PACKAGE_\|_ );
\&        while (<$handle>) {
\&            print $_;
\&        }
\&    }
\&
\&    _\|_DATA_\|_
\&    Foo
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Package serves as a very \fIvery\fR simple interface to a packages _\|_DATA_\|_ section.
.PP
Its primary purposes is to make successive accesses viable without needing to
scan the file manually for the _\|_DATA_\|_ marker.
.PP
It does this mostly by recording the current position of the file handle on
the first call to \f(CW\*(C`\->new\*(C'\fR, and then re-using that position on every successive \f(CW\*(C`\->new\*(C'\fR call,
which eliminates a bit of the logic for you.
.PP
At present, it only does a simple heuristic ( backtracking ) to verify the current position is \fBimmediately\fR
at the start of a _\|_DATA_\|_ section, but we may improve on this one day.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $fh = Data::Handle\->new( $targetpackage )
.Ve
.PP
Where \f(CW$targetpackage\fR is the package you want the _\|_DATA_\|_ section from.
.SH "WARNING"
.IX Header "WARNING"
At present, this module does you no favours if something else earlier has moved the file handle position past
the _\|_DATA_\|_ section, or rewound it to the start of the file. This is an understood caveat, but nothing else
seems to have a good way around this either. ( You can always rewind to the start of the file and use heuristics, but that is rather pesky ).
.PP
Hopefully, if other people \fBdo\fR decide to go moving your file pointer, they'll use this module to do it so
you your code doesn't break.
.SH "USAGE"
.IX Header "USAGE"
\&\f(CW\*(C`Data::Handle\-\*(C'\fR\fInew()\fR> returns a tied file-handle, and for all intents and purposes, it should
behave as if somebody had copied _\|_DATA_\|_ to its own file, and then done \f(CW\*(C`open $fh, \*(Aq<\*(Aq , $file\*(C'\fR
on it, for every instance of the Data::Handle.
.PP
It also inherits from IO::File, so all the methods it has that make sense to use should probably work
on this too,  i.e.:
.PP
.Vb 2
\&    my $handle = Data::Handle\->new( _\|_PACKAGE_\|_ );
\&    my @lines = $handle\->getlines();
.Ve
.PP
Also, all offsets are proxied in transit, so you can treat the file-handle as if byte 0 is the first byte of the data section.
.PP
.Vb 5
\&    my $handle = Data::Handle\->new( _\|_PACKAGE_\|_ );
\&    my @lines = $handle\->getlines();
\&    seek $handle, 0, 0;
\&    local $/ = undef;
\&    my $line = scalar <$handle>; # SLURPED!
.Ve
.PP
Also, the current position of each handle instance is internally tracked, so you can have as many
objects pointing to the same _\|_DATA_\|_ section but have their read mechanism uninterrupted by any others.
.PP
.Vb 2
\&    my $handlea  = Data::Handle\->new( _\|_PACKAGE_\|_ );
\&    my $handleb  = Data::Handle\->new( _\|_PACKAGE_\|_ );
\&
\&    seek $handlea, 10, 0;
\&    seek $handleb, 15, 0;
\&
\&    read $handlea, my $buf, 5;
\&
\&    read $handleb, my $bufa, 1;
\&    read $handleb, my $bufb, 1;
\&
\&     $bufa eq $bufb;
.Ve
.PP
Don't be fooled, it does this under the covers by a lot of \f(CW\*(C`seek\*(C'\fR/\f(CW\*(C`tell\*(C'\fR magic, but they shouldn't be a problem unless you are truly anal over speed.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks to LeoNerd and anno, from #perl on irc.freenode.org,
they were most helpful in helping me grok the magic of \f(CW\*(C`tie\*(C'\fR that
makes the simplicity of the interface possible.
.PP
Thanks to Chas Owens and James Wright for their efforts with trying to get something simpler with \fIfdup()\fRing the descriptor ( Sadly not working yet ).
.SH "AUTHOR"
.IX Header "AUTHOR"
Kent Fredric <kentnl@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Kent Fredric <kentnl@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
